# Лабораторная работа №2:

**Группа:** `ПМ-2502`  
**Студент:** `Ртищев Егор Андреевич` <br>
**Вариант:** `18`

---

## Задание 1: Генерация последовательности

**Условие:**  
Исследовать последовательность, определяемую рекуррентным соотношением:  
a₀ = заданное число  
aₙ = 2 × S(aₙ₋₁) для n ≥ 1  
где S(x) — сумма цифр числа x.

### Постановка задачи
Ваша задача – посмотреть, какие значения принимает последовательность при разных a₀ и n, вывести закономерность, по которой строится последовательность и запрограммировать ее самостоятельно.

### Входные и выходные данные

| Параметр | Тип | Диапазон | Описание |
|----------|-----|----------|----------|
| a₀ | Целое число | ($-2^{31}$, $2^{31}$)  | Начальное значение последовательности |
| n | Целое число | n ≥ 1 | Количество генерируемых элементов |
| **Выходные данные** | Последовательность целых чисел | — | n элементов последовательности |

### Алгоритм
1. **Инициализация:** Считываем a₀ и n.
2. **Генерация последовательности:** Для i от 1 до n:
   - Вычислить сумму цифр текущего значения.
   - Умножить на 2 для получения следующего элемента.
   - Сохранить для следующей итерации.
3. **Вывод:** Вывести все сгенерированные элементы.

### Программа
```java
import java.io.PrintStream;
import java.util.Scanner;

public class laba2_zadanie1 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    // Подпрограмма для подсчёта суммы цифр в числе
    public static int sumDigit(int n) {
        int sum = 0;
        while (n != 0) {
            sum += n % 10;
            n /= 10;
        }
        return sum;
    }

    public static void main(String[] args) {
        // Вводим первый элемент последовательности и количество элементов
        int a_0 = in.nextInt();
        int n = in.nextInt();

        // Создаём переменную previous, где будем хранить предыдущий член последовательности
        int previous = a_0;

        // Создаём переменную current, где будем хранить текущий член последовательности
        int current = 0;

        // Создаём последовательность и выводим её на экран 
        for (int i = 1; i <= n; i++) {
            current = sumDigit(previous) * 2;
            out.print(current + " ");
            previous = current;
        }
    }
}
```
### Анализ правильности решения
**Тесты:** <br>
Ввод:<br> 0 5 <br>
Вывод:<br> 0 0 0 0 0 <br>
Ввод:<br> 1 5 <br>
Вывод:<br> 2 4 8 16 14 <br>
Ввод:<br> 999999999 4 <br>
Вывод:<br> 162 18 18 18  <br>
Ввод:<br> 123 5 <br>
Вывод: <br>12 6 12 6 12 <br>

## Задание 2: Троичное число из единиц

**Условие:**  
С клавиатуры вводится натуральное число N (N < 20). Вывести на экран десятичное представление числа, которое в троичном виде состоит из N единиц.

### Входные и выходные данные

| Параметр | Тип | Диапазон | Описание |
|----------|-----|----------|----------|
| N | Натуральное число | 1 ≤ N < 20 | Количество единиц в троичном числе |
| **Выходные данные** | Целое число | 1 ≤ результат ≤ (3^20 - 1)/2 | Десятичное представление |


### Алгоритм
1. Ввод N.
2. Вычисление суммы геометрической прогрессии:
   - Результат = 0
   - Для i от 0 до N-1:
     - Добавить digit к результату.
     - digit *= 3.
3. Вывод результата.

### Программа
```java
import java.io.PrintStream;
import java.util.Scanner;
public class laba2_zadanie2 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args){
        // Вводим n с клавиатуры
        int n = in.nextInt();
        // Создаём переменную, в которой будем хранить десятичное значение исходного числа
        int dec_number = 0;
        int digit = 1;
        for (int i = 0; i < n; i++){
            // Переводим каждую цифру троичного числа в десятичную запись и добавляем
            //                это значение в переменную  dec_number
            dec_number += digit;
            digit *= 3;
        }
        out.print(dec_number);
    }
}
```
### Анализ правильности решения

**Тесты:** <br>
Ввод:<br> 1 <br>
Вывод:<br> 1 <br>
Ввод:<br> 19 <br>
Вывод:<br> 581130733 <br>


  ## Задание 3: Моделирование роста населения

**Условие:**  
Микрорайон с начальной численностью населения P₀ развивается по годам: каждый год к текущему населению прибавляется прирост, равный целой части выражения P × g / 100, после чего учитывается миграция m. Смоделируйте развитие до момента завершения процесса. Выведите: (1) сколько полных лет прошло к моменту завершения процесса; (2) итоговую численность населения (если она превысила Cap, вывести ровно Cap).

**Формат ввода:**  
P0, g, m, Cap

### Входные и выходные данные

| Параметр | Тип | Описание |
|----------|-----|----------|
| P₀ | Целое число ≥ 0 | Начальная численность |
| g | Целое число ≥ 0 | Ежегодный темп прироста в % |
| m | Целое число | Ежегодная миграция |
| Cap | Целое число > 0 | Вместимость микрорайона |
| **Выходные данные** | Два целых числа | Количество лет и итоговое население |

### Алгоритм
Пока `текущее_население` < `Cap`: <br>
   `прирост` = `текущее_население` × `g` / 100 <br>
   `текущее_население` += `прирост` <br>
   если `текущее_население` < `Cap`: <br>
      увеличить `счётчик_лет` на 1 <br>
   `текущее_население` += `миграция` <br>
`текущее_население` = `Cap` <br>
Вывод: `счётчик лет` и `текущее население`
**Код:**
```java
import java.io.PrintStream;
import java.util.Scanner;
public class laba2_zadanie3 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args){
        // Вводим с клавиатуры вводные данные 
        int P0 = in.nextInt();
        int g = in.nextInt();
        int m = in.nextInt();
        int Cap = in.nextInt();

        // Создаём переменную P_current, где будем хранить текущую численность населения
        // (можно было хранить её в P0, но для лучшей читабельности создал лишнюю перемнную)
        int P_current = P0;
        // Создаём переменную, где будем хранить текущее количество лет, прошедших с точки отсчёта
        int number_of_years = 0;
        while (P_current < Cap){
            // Применяем формулу, указанную в условии задачи
            P_current += P_current * g / 100;
            if (P_current < Cap){
                number_of_years += 1;
            }
            P_current += m;
        }
        P_current = Cap;
        out.print(number_of_years + " " + P_current);
    }
}
```
**Тесты:** <br>
Ввод:<br> 1000 5 50 2000 <br>
Вывод:<br> 8 2000 <br>
Ввод:<br> 500 0 20 600<br>
Вывод:<br> 5 600 <br>
Ввод: <br>1500 10 100 1500 <br>
Вывод:<br> 0 1500 <br>
Ввод:<br> 100 50 0 101 <br>
Вывод:<br> 0 101 <br>
## Задание 4: Анализ частоты элементов

**Условие:**  
Дана последовательность из n элементов. Известно, что все ее элементы находятся в диапазоне от 10 до 100 (включая границы). Определить, есть ли такие элементы, которые встречаются в последовательности ровно столько раз, каково их значение. Если такие элементы есть – вывести их значения, если их нет – вывести "NO".

**Формат ввода:**  
n  
a₁ a₂ ... aₙ

### Входные и выходные данные

| Параметр | Тип | Диапазон | Описание |
|----------|-----|----------|----------|
| n | Целое число | n ≥ 0 | Длина последовательности |
| aᵢ | Целое число | 10 ≤ aᵢ ≤ 100 | Элементы последовательности |
| **Выходные данные** | Числа или "NO" | — | Элементы, если количество вхождений = значению |

### Алгоритм
1. Создаём массив для хранения количества вхождений числа
2. Для каждого из n элементов:
   - Считывается очередное число
   - Увеличивается счетчик элемента массива с индексом i + 10 на 1
3. Перебираются все возможные значения от 10 до 100 включительно
   Для каждого числа проверяется:
   - Совпадает ли его частота с самим значением <br> 
4. Если условие выполняется → число выводится и устанавливается флаг flag = true
5. Если после цикла flag == false → выводим "NO"
### Программа
```java
import java.io.PrintStream;
import java.util.Scanner;
public class laba2_zadanie4 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args){
        // Вводим n с клавиатуры
        int n = in.nextInt();
        // Создаём переменную current_number для хранения текущего числа и 
        //               вспомогательный boolean flag
        int current_number = 0;
        boolean flag = false;
        // Создаём массив для хранения числа вхождений чисел
        int [] numbers = new int[91];
        for (int i = 0; i < n; i++){
            current_number = in.nextInt();
            numbers[current_number - 10] += 1; 
        }
        for (int i = 0; i <= 90; i++){
            if (numbers[i] == i + 10){
                out.print((i + 10) + " ");  
                flag = true;  
            }
        }
        if (!flag){
            out.print("NO");
        }
    }
}
```
**Тесты:**<br>
Ввод: <br>
10 <br>
10 10 10 10 10 10 10 10 10 10 <br>
Вывод: <br>
10 <br>
Ввод: <br>
21 <br>
10 10 10 10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 11 11 11 <br>
Вывод:<br>
10 11 <br>
Ввод: <br>
10 <br>
10 10 10 10 10 10 10 10 10 11 <br>
Вывод:<br> NO <br>
